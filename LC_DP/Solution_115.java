package leetcode.LC_DP;

public class Solution_115 {

    /**
     * dp 动态规划
     * 含义：
     *      dp[i][j] 表示 s 的前 i 个字符中为 t 的前 j 个字符的子序列有多少个
     *      【注意 i 、j 非下标，因为前 0 个字符（即空字符串）也是有意义的】
     * 状态转移：
     *      【划分一：看 s 的第 i 个字符 s[i-1] 和 t 的第 j 个字符 t[j-1] 是否相同】
     *      【划分二：在 s[i-1] 和 t[j-1] 两个字符相等即可以匹配的情况下，t[j-1] 可以选择匹配或不匹配 s[i-1]】
     *      【例如 s = bagg 和 t = bag 中 s[3] == t[2]】
     *      【若是 t[2] 匹配 s[3] ，则是用 s[0][1][3] 子序列作为匹配整个 t 的一种方案】
     *      【若是 t[2] 不匹配 s[3] ，则是用 s[0][1][2] 子序列作为匹配整个 t 的一种方案】
     *      dp[i][j] = dp[i-1][j] + dp[i-1][j-1]         在 s[i-1] == t[j-1] 的情况下
     *      dp[i][j] = dp[i-1][j]                        在 s[i-1] != t[j-1] 的情况下
     *      【项分析一：dp[i-1][j]    正上方】
     *      【项分析二：dp[i-1][j-1]  左上角】
     * 遍历顺序：
     *      【保证正上方和左上角更新计算过了】
     *      【第一维度 i 必须正序遍历，且 i=0 第一行没有左上角和正上方，需要手动初始化，即 i 正序遍历 [1 -> len(s)]】
     *      【第二维度 j 在上 i-1 层更新计算过后，正序逆序无所谓，范围分析如下：】
     *          【第一列 dp[0][0] 没有正上方和左上方，其他 dp[1~len(s)][0] 仅没有左上方，但有正上方】
     *          【首先分析 j=0 第一列语义为 t 的前 0 个字符，即可以理解为 t[-1] = 空字符串】
     *          【对于 dp[1~len(s)][0] 来说，必然是在 s[i-1] != t[-1] 的情况下】
     *          【则可以通过状态转移方程 dp[i][j] = dp[i-1][j] 依赖其正上方（存在）更新计算，即直接遗传其正上方的值】
     *          【对于 dp[0][0] 来说，必然是在 s[-1] == t[-1] 的情况下，状态转移方程中需要依赖正上方（不存在）和左上方（不存在）】
     *          【所以必须手动初始化 dp[0][0]】
     *      【综上所述，则 j 可以从 1 开始，范围为 [1 ~ len(t)] ，配合手动初始化 dp[0][0] 和 dp[1~len(s)][0]】
     *      【虽然 dp[1~len(s)][0] 可以依据状态转移方程更新计算，但在条件分支中去特意判断 s[i-1] != t[-1] 会显得复杂】
     *      【所以不如直接手动初始化了，反正也是直接遗传正上方 dp[0][0] 的值】
     *      策略一：先 i 正序，再 j 正序逆序都可以
     *      策略二：先 j 正序，再 i 正序
     *      注意：先 j 的话不能逆序，不然无法保证左上方已经更新计算过了
     * 初始化：
     *      dp[0][j] = 0    在 j 不等于 0 的情况下，字符串 s 的前 0 个空字符串中，必然不存在字符串 t 的前 j 个字符的子序列
     *      dp[0][0] = 1
     *      dp[i][0] = 1    依次自动遗传正上方 dp[i-1][0] 的 1 值
     */
    public int numDistinct1(String s, String t) {

        int n = s.length();
        int m = t.length();
        char[] chS = s.toCharArray();
        char[] chT = t.toCharArray();

        // 初始化，dp[0][j] = 0 直接使用数组默认值 0 即可
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0 ; i <= n ; i++) {
            dp[i][0] = 1;
        }

        for (int i = 1 ; i <= n ; i++) {
            for (int j = 1; j <= m; j++) {
                if (chS[i - 1] == chT[j - 1]) {
                    dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1];
                } else {
                    dp[i][j] = dp[i - 1][j];
                }
            }
        }
        return dp[n][m];
    }

    /**
     * 二维化一维，空间优化：
     *      对原始二维进行项分析：
     *          dp[i-1][j-1] 左上方 == dp[j-1] 旧值
     *          dp[i-1][j]   正上方 == dp[j]   旧值
     *          【所以 j 逆序遍历，避免破坏 dp[j-1] 旧值，也免得用一个 upperLeft 去记录了】
     *      状态转移：
     *          dp[j] += dp[j-1]         在 s[i-1] == t[j-1] 的情况下
     *          dp[j] = dp[j]            在 s[i-1] != t[j-1] 的情况下，即直接遗传自身旧值
     *      遍历顺序：
     *          【外层 i 正序遍历 [1 -> len(s)] 上述二维算法的 i=0 第一行也仅初始化了一个 dp[0][0] ，其他取数组默认值 0 即可】
     *          【内层 j 逆序遍历 [len(t) -> 1] 配合初始化 dp[0] = 1 】
     *      初始化：
     *          【保持与原始二维算法一模一样】
     *          dp[0] = 1     且再也无需更改了，则同时满足了上述二维算法的 i=0 初始化和 j=0 初始化
     */
    public int numDistinct2(String s, String t) {
        // preliminary
        int n = s.length();
        int m = t.length();
        char[] chS = s.toCharArray();
        char[] chT = t.toCharArray();

        // 初始化
        int[] dp = new int[m + 1];
        dp[0] = 1;

        for (int i = 1 ; i <= n ; i++) {
            for (int j = m; j >= 1; j--) {
                if (chS[i - 1] == chT[j - 1]) {
                    dp[j] += dp[j - 1];
                } // 可省略 else dp[j] = dp[j]
            }
        }
        return dp[m];
    }
}