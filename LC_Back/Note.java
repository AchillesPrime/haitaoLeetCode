package leetcode.LC_Back;

/**
 * 组合系列：<p>
 *      【需要 startIndex】
 *       77 ：求组合 C_n^k
 *       78 ：无重复元素 nums[] 的所有子集
 *       90 ：有重复元素 nums[] 的所有子集
 *       39 ：无重复元素 candidates[] 和 target ，且 candidates[] 每个元素都可重复取，求所有的和 == target 的组合
 *       40 ：有重复元素 candidates[] 和 target ，且 candidates[] 每个元素只能取一次，求所有的和 == target 的组合
 *      216 ：从 [1 , 2 , ... , 9] 中选 k 个数使得总和为 n ，每个元素只能取一次（即 77 + 39 + 40）
 *      491 ：有重复元素的、无序的数组 nums[] 中找出所有的递增子序列，至少包含两个元素，且在不同层选择两个相等的数也视为一种递增序列的情况
 *      【无需 startIndex】
 *       17 ：数字 --> 电话按键 --> 字母（在多个集合里面求组合，每个集合占一层递归，每个集合在每层递归中从头到尾遍历一遍）
 *      【需要 startIndex 的分割】
 *      131 ：将字符串 s 分割为回文子串的所有分割方案，单个字母也算一个回文串
 *       93 ：将字符串 s 分割为有效 IP 地址的所有分割方案，有效 IP 地址 == 4 个 [0 ~ 255] 范围内的不含前导 0 的整数
 * <hr>
 * 排列系列：<p>
 *      【无需 startIndex 但需要一个 used[] 记录哪些元素已经被之前层取过了】
 *      46 ：无重复元素 nums[] 的全排列
 *      47 ：有重复元素 nums[] 的全排列
 * <hr>
 * 棋盘系列：<p>
 *      【主要是判断当前递归层能不能放置这个棋子】
 *      【返回值为 boolean 表示只要找到一种方案就不找了】
 *      【返回值为 int 表示累加求方案数】
 *      【递归参数列表的局部变量不需要回溯】
 *      36 ：判断数独是否有效，即在 9×9 的数独中，数字 [1~9] 在每一行、每一列、每一个 3×3 小格中仅能出现一次
 *      37 ：在 36 的规则上，求给定原始数独的唯一解，题目保证解仅有一个
 *      51 ：在 n×n 棋盘上放置 n 个皇后，不能同行、同列、同斜线，求所有的放置方案
 *      52 ：在 51 的基础上，返回放置的总方案数
 */

public class Note {

    public static void main(String[] args) {
    }
}
