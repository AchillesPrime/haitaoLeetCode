package leetcode.LC_Array;

/**
 * 二分法系列：<p>
 *      704 ：二分法的三种模板
 *        4 ：两个有序数组的中位数（第 k 小元素）（难题）（遗留问题）
 *       69 ：计算 x 的平方根
 *       34 ：有重复元素，有序数组 nums[] 中找第一个 target 和最后一个 target
 *       35 ：无重复元素，有序数组 nums[] 中找插入 target 的位置
 *      162 ：在 nums[] 中找任意一个峰值元素
 *      【旋转数组】
 *       33 ：搜索是否存在，无重复元素
 *       81 ：搜索是否存在，有重复元素
 *      153 ：搜索最小值，无重复元素
 *      154 ：搜索最小值，有重复元素
 *      【搜索二维矩阵系列】
 *       74 ：搜索是否存在，每一行连续有序（坐标 Hash）
 *      240 ：搜索是否存在，行有序，列有序
 *      378 ：第 k 小元素，行有序，列有序
 *       73 ：将 matrix[][] 中 0 元素所在的行、列都置为 0
 *       54 ：顺时针螺旋顺序读取 matrix[][]（仅遗留问题）
 *       59 ：顺时针螺旋顺序生成 matrix[][]（仅遗留问题）
 *       48 ：将 matrix[][] 原地顺时针旋转 90°（仅遗留问题）
 * <hr>
 * 双指针系列：<p>
 *      【逆向思维】
 *       88 ：合并两个有序数组
 *      977 ：升序排序 nums[] 的平方项
 *      【双向移动 l & r】
 *       11 ：在 height[] 中找两块木板 l 和 r 使其中间的容水量 [l ~ r] 最大
 *       581 ：找 nums[] 中最短的一个连续子数组，若对该连续子数组排序后，则整个 nums[] 即有序了
 *      【滑动区间 + 连续子数组】
 *      713 ：给定 nums[] 和 k ，求 nums[] 的连续子数组的个数，连续子数组的元素乘积需要 < k
 *      209 ：找 nums[] 中最短的一个连续子数组，该连续子数组应满足元素和 >= target
 * <hr>
 * 有效尾指针系列：<p>
 *       【idx == 待填充元素的位置 == 数组长度】
 *       【idx-1 == 有效尾指针】
 *       26 ：逻辑删除 nums[] 中的重复值，只保留 1 个
 *       27 ：逻辑删除 nums[] 中的 val 值
 *       80 ：逻辑删除 nums[] 中的重复值，至多保留 2 个
 *      283 ：将 nums[] 中的 0 都移到数组末尾，且保持其他非零元素的相对顺序（双指针交换）
 * <hr>
 * 找元素系列：<p>
 *      【找重复的（Set）】
 *      217 ：判断 nums[] 中是否有元素重复
 *      287 ：给出 [1 , n] 范围中的 n+1 个数，且只有一个数重复了（2 ~ 多次），找出那个重复的数
 *      202 ：快乐数，是否 n --> ... --> 每一位数的平方和 --> ... --> 1
 *      【找未重复的（异或位运算）】
 *      136 ：nums[] 中只有一个元素仅出现了一次，其他元素都出现了两次，找出仅出现了一次的那个元素
 *      137 ：nums[] 中只有一个元素仅出现了一次，其他元素都出现了三次，找出仅出现了一次的那个元素
 *      260 ：nums[] 中只有两个元素仅出现了一次，其他元素都出现了两次，找出仅出现了一次的那两个元素
 *      【找不存在的（把把值 [1 , n] 放到下标 [0 , n-1] 处，或标记到 [0 , n-1] 处）】
 *      268 ：给出 [0 , n] 范围内的 n 个数，无重复，找出未给出的那个数
 *      448 ：给出 [1 , n] 范围内的 n 个数，有重复，找出未给出的所有数
 *       41 ：有负数，找 nums[] 中未给出的最小正整数，正整数从 1 开始
 * <hr>
 * 排序系列：<p>
 *      912 ：对 nums[] 进行插入排序、快排、归并排序、堆排序
 *      【快排应用】
 *      215 ：求 nums[] 中第 k 大的元素（快排 & 堆排）
 *       75 ：荷兰三色旗，将 nums[] 按 0 、1 、2 排序，典型的快排思想应用
 *      324 ：摆动排序，将 nums[] 排序为 nums[0] < nums[1] > nums[2] < nums[3] > ...（难题）（遗留问题）
 *      【归并排序应用】
 *      315 ：计算每个元素 nums[i] 的右侧 nums[i+1 ~ n-1] 中比其值小的元素的个数，即逆序对
 * <hr>
 * 模拟过程系列：<p>
 *      66 ：视 nums[] 为正整数，在其个位数 nums[n-1] 处 + 1 ，返回结果 nums[]
 *      29 ：模拟整数除法，向下取整，不能使用 * / % 等运算符
 * <hr>
 * 其他：
 *      189 ：将 nums[] 向右轮转 k 个位置
 *      238 ：将 nums[i] 更新为 nums[0 ~ i-1] 和 nums[i+1 ~ n-1] 的乘积
 *      172 ：求 n! 中有几个末尾 0
 *      204 ：求 [2 , n-1] 内的质数
 *      118 ：生成前 numRows 行的杨辉三角
 *      292 ：博弈
 *       31 ：下一个字典序更大的 nums[] 排列
 *
 * 摩尔投票法系列：
 *      169 ：在 nums[] 中找出出现次数 > n/2 （向下取整）的元素，题目保证必定存在该多数元素
 *      229 ：在 nums[] 中找出出现次数 > n/3 （向下取整）的元素，题目不保证一定存在
 */

public class Note {
}
